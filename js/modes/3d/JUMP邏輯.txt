// --- JS 端的深度跳躍邏輯實作 ---

// 1. 設定妳在 Unity 捏好的參數
const JUMP_CONFIG = {
    controlStart: 0.3,   // 30% 開始動
    landPoint: 0.7,      // 70% 停下來
    airSpeedBase: 3.0,   // 走路跳速度
    sprintBonus: 1.5     // 跑步跳加成
};

function update3DPlayerLogic(deltaTime) {
    // 取得當前正在播的動作 (假設是 Jump)
    const jumpAction = actions['Jump']; 
    
    if (jumpAction && jumpAction.isRunning()) {
        // --- 核心：計算動畫進度 (等同 Unity 的 normalizedTime) ---
        let progress = jumpAction.time / jumpAction.getClip().duration;

        // 邏輯 A：起跳鎖定 (0% ~ 30%)
        if (progress < JUMP_CONFIG.controlStart) {
            return; // 絕對不執行位移
        }

        // 邏輯 B：空中控制 (30% ~ 70%)
        if (progress >= JUMP_CONFIG.controlStart && progress < JUMP_CONFIG.landPoint) {
            // 讀取妳 JS 專案裡的按鍵方向 (這部分妳原本的 js/input.js 應該有)
            let moveDir = getPlayerInputDirection(); 

            if (moveDir.length() > 0) {
                // 計算最終速度 (如果是起跳前在跑步，就加 bonus)
                let finalSpeed = wasRunningWhenJumped ? 
                    (JUMP_CONFIG.airSpeedBase + JUMP_CONFIG.sprintBonus) : 
                    JUMP_CONFIG.airSpeedBase;

                // 執行位移
                playerModel.position.add(moveDir.multiplyScalar(finalSpeed * deltaTime));
                
                // 轉向
                playerModel.lookAt(playerModel.position.clone().add(moveDir));
            }
        }

        // 邏輯 C：落地即停 (70% ~ 100%)
        if (progress >= JUMP_CONFIG.landPoint) {
            // 這裡什麼都不寫，位移就會自然停止，直到動畫結束回到 Idle
        }
        
        // 邏輯 D：防止空中重複觸發 (妳發現的那個連跳 Bug)
        // 在 JS 裡我們直接在按鍵判斷那邊寫：if(isJumping) return; 就解決了
    }
}